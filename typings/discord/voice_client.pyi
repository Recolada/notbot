"""
This type stub file was generated by pyright.
"""

import socket
import logging
from .gateway import *
from typing import Any, Optional

"""
The MIT License (MIT)

Copyright (c) 2015-2019 Rapptz

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
"""
log = logging.getLogger(__name__)
class VoiceClient:
    """Represents a Discord voice connection.

    You do not create these, you typically get them from
    e.g. :meth:`VoiceChannel.connect`.

    Warning
    --------
    In order to play audio, you must have loaded the opus library
    through :func:`opus.load_opus`.

    If you don't do this then the library will not be able to
    transmit audio.

    Attributes
    -----------
    session_id: :class:`str`
        The voice connection session ID.
    token: :class:`str`
        The voice connection token.
    endpoint: :class:`str`
        The endpoint we are connecting to.
    channel: :class:`abc.Connectable`
        The voice channel connected to.
    loop: :class:`asyncio.AbstractEventLoop`
        The event loop that the voice client is running on.
    """
    def __init__(self, state, timeout, channel):
        self.channel = ...
        self.main_ws = ...
        self.timeout = ...
        self.ws = ...
        self.socket = ...
        self.loop = ...
        self.mode = ...
        self.sequence = ...
        self.timestamp = ...
        self.encoder = ...
    
    warn_nacl = ...
    supported_modes = ...
    @property
    def guild(self):
        """Optional[:class:`Guild`]: The guild we're connected to, if applicable."""
        ...
    
    @property
    def user(self):
        """:class:`ClientUser`: The user connected to voice (i.e. ourselves)."""
        ...
    
    def checked_add(self, attr, value, limit):
        ...
    
    async def start_handshake(self):
        self.main_ws = ...
    
    async def terminate_handshake(self, *, remove: bool = ...):
        ...
    
    async def _create_socket(self, server_id, data):
        self.session_id = ...
        self.server_id = ...
        self.token = ...
        self.endpoint = ...
        self.endpoint_ip = ...
        self.socket = ...
    
    async def connect(self, *, reconnect: bool = ..., _tries=..., do_handshake: bool = ...):
        ...
    
    async def poll_voice_ws(self, reconnect):
        ...
    
    async def disconnect(self, *, force: bool = ...):
        """|coro|

        Disconnects this voice client from voice.
        """
        ...
    
    async def move_to(self, channel):
        """|coro|

        Moves you to a different voice channel.

        Parameters
        -----------
        channel: :class:`abc.Snowflake`
            The channel to move to. Must be a voice channel.
        """
        ...
    
    def is_connected(self):
        """Indicates if the voice client is connected to voice."""
        ...
    
    def _get_voice_packet(self, data):
        ...
    
    def _encrypt_xsalsa20_poly1305(self, header, data):
        ...
    
    def _encrypt_xsalsa20_poly1305_suffix(self, header, data):
        ...
    
    def play(self, source, *, after: Optional[Any] = ...):
        """Plays an :class:`AudioSource`.

        The finalizer, ``after`` is called after the source has been exhausted
        or an error occurred.

        If an error happens while the audio player is running, the exception is
        caught and the audio player is then stopped.

        Parameters
        -----------
        source: :class:`AudioSource`
            The audio source we're reading from.
        after: Callable[[:class:`Exception`], Any]
            The finalizer that is called after the stream is exhausted.
            All exceptions it throws are silently discarded. This function
            must have a single parameter, ``error``, that denotes an
            optional exception that was raised during playing.

        Raises
        -------
        ClientException
            Already playing audio or not connected.
        TypeError
            source is not a :class:`AudioSource` or after is not a callable.
        """
        ...
    
    def is_playing(self):
        """Indicates if we're currently playing audio."""
        ...
    
    def is_paused(self):
        """Indicates if we're playing audio, but if we're paused."""
        ...
    
    def stop(self):
        """Stops playing audio."""
        ...
    
    def pause(self):
        """Pauses the audio playing."""
        ...
    
    def resume(self):
        """Resumes the audio playing."""
        ...
    
    @property
    def source(self):
        """Optional[:class:`AudioSource`]: The audio source being played, if playing.

        This property can also be used to change the audio source currently being played.
        """
        ...
    
    @source.setter
    def source(self, value):
        ...
    
    def send_audio_packet(self, data, *, encode: bool = ...):
        """Sends an audio packet composed of the data.

        You must be connected to play audio.

        Parameters
        ----------
        data: :class:`bytes`
            The :term:`py:bytes-like object` denoting PCM or Opus voice data.
        encode: :class:`bool`
            Indicates if ``data`` should be encoded into Opus.

        Raises
        -------
        ClientException
            You are not connected.
        opus.OpusError
            Encoding the data failed.
        """
        ...
    


